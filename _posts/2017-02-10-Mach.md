---
layout: post
title:  "XNU - Mach"
date:   2017-02-10 12:00:00
categories: blog
---
`Darwin` is the open source portion of the operating systems that Apple ships in their products. This includes the kernel, a variety of libraries, command line tools, and device drivers. The core architecture of the operating system relies on the kernel, which handles input/output from all software requests and translates them into machine level instructions that the CPU can understand. It provides the most fundamental levels of abstraction so that applications and other software can be written in an environment where this is not of a concern of developers. 

The kernel for iOS/macOS is called `XNU`, which is a recursive acronym for "XNU is not Unix". It was originally developed by NextStep, and it shipped as a hybrid kernel. Its original components derive from the Mach microkernel, developed at Carnegie Mellon University, and the 4.3BSD subsystems. NextStep's original vision for XNU contained an Objective C API for device drivers, and it was called Driver Kit. Later, when Apple acquired Next, it was replaced with IOKit, a framework that allows device drivers to be written in embedded C++.

The 'Mach' microkernel is the most fundamental layer of XNU. Being a microkernel, it is a super thin, minimal, and lightweight level of abstraction where components can communicated with via `messages`. Mach is intended to be a surface level interface in which an operating system itself can be implemented on top of. XNU happens to one of the few modern Unix based operating systems that was implemented on top of Mach.

The unique thing about Mach is that it contains an interface by which objects are communicated with through message passing. Mach objects can not directly be interfaced with or invoked on one another. The object that is the source of a message sends a message to a destination object, and the destination object queues the message until it can process and handle it. The content of the message is up to the sender to decide and what the destination object does in response is to its discretion.

The fundamental unit within Mach is a message, and it can be passed to an endpoint, also known as a `port`. Let's take a look at how messages actually look with Mach. In `<mach/message.h>`, we find

```c
typedef struct {
    mach_msg_header_t header;
    mach_msg_body_t body; 
} mach_msg_base_t;
```
The msg_header contains the metadata about the message. 

```c
typedef	struct 
{
    mach_msg_bits_t	msgh_bits;
    mach_msg_size_t	msgh_size;
    mach_port_t		msgh_remote_port;
    mach_port_t		msgh_local_port;
    mach_port_name_t	msgh_voucher_port;
    mach_msg_id_t		msgh_id;
} mach_msg_header_t;
```

`mach_msg()` is a function within Mach's API's that perform the actual sending/receiving of a message. The function actually has an implementation in user mode.

```c
mach_msg_return_t mach_msg(mach_msg_header_t *msg,
                           mach_msg_option_t option,
                           mach_msg_size_t send_size,
                           mach_msg_size_t rcv_size,
                           mach_port_name_t rcv_name,
                           mach_msg_timeout_t timeout,
                           mach_port_name_t notify);
```
These messages are sent between ports, the type `mach_port_t`. They are just 32 bit identifiers. Each port may receive messages from an infinite number of senders but only has one receiver, which means the messages have to be queued until they can be processed. 

Mach objects are accessed through their ports. When you want a handle to some object, you are essentially aiming to seek a handle to the corresponding object's port. Port access is maintained by a set of port rights, which are defined in `<mach/port.h>`. 

```c
#define MACH_PORT_RIGHT_SEND		((mach_port_right_t) 0)
#define MACH_PORT_RIGHT_RECEIVE		((mach_port_right_t) 1)
#define MACH_PORT_RIGHT_SEND_ONCE	((mach_port_right_t) 2)
#define MACH_PORT_RIGHT_PORT_SET	((mach_port_right_t) 3)
#define MACH_PORT_RIGHT_DEAD_NAME	((mach_port_right_t) 4)
#define MACH_PORT_RIGHT_LABELH	        ((mach_port_right_t) 5)
#define MACH_PORT_RIGHT_NUMBER		((mach_port_right_t) 6)
```

So now you should have a basic understanding of message passing in Mach. Let's see how message passing is used in action. 

```c
static int32_t setup_receive_port(mach_port_t *receive_port){
    kern_return_t       err;
    mach_port_t         port = MACH_PORT_NULL;

    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);

    if(err != KERN_SUCCESS){
        return -1;
    }

    err = mach_port_insert_right(mach_task_self(),
                                 port,
                                 port,
                                 MACH_MSG_TYPE_MAKE_SEND);
    if(err != KERN_SUCCESS){
        return -1;
    }

    *recv_port = port;
    return 0;
}
```
This function allocates a new mach_port_t that handles the receiving of the message that contains the handle to the parent task port. It sets the port rights of the parent's task to allow sending messages to this port.

```c
static int32_t send_port(mach_port_t remote_port, 
                         mach_port_t port){
    kern_return_t err;

    struct
    {
        mach_msg_header_t          header;
        mach_msg_body_t            body;
        mach_msg_port_descriptor_t task_port;
    } msg;

    msg.header.msgh_remote_port = remote_port;
    msg.header.msgh_local_port = MACH_PORT_NULL;
    msg.header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0)
                                          | MACH_MSGH_BITS_COMPLEX;
    msg.header.msgh_size = sizeof msg;

    msg.body.msgh_descriptor_count = 1;
    msg.task_port.name = port;
    msg.task_port.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.task_port.type = MACH_MSG_PORT_DESCRIPTOR;

    err = mach_msg_send(&msg.header);
    if(err != KERN_SUCCESS){
        return -1;
    }

    return 0;
}
```
This function sends the message to the remote port with a custom msg structure defined in the function with our required header and body fields included.

```c
static int32_t receive_port(mach_port_t receive_port, 
                            mach_port_t *port){
    kern_return_t err;

    struct{
        mach_msg_header_t          header;
        mach_msg_body_t            body;
        mach_msg_port_descriptor_t task_port;
        mach_msg_trailer_t         trailer;
    } msg;

    err = mach_msg(&msg.header, 
                   MACH_RCV_MSG, 
                   0,
                   sizeof msg, 
                   recv_port, 
                   MACH_MSG_TIMEOUT_NONE, 
                   MACH_PORT_NULL);

    if(err != KERN_SUCCESS){
        return -1;
    }

    *port = msg.task_port.name;
    return 0;
}
```
This function uses `mach_msg()` to retrieve the task port of the parent from the message's metadata.

Basically this example, even though it doesn't contain the code for forking a process, passes the parent task port to the child process forked from the parent. Notice how we have to set up a receive port for passing the task port from the parent using the function `mach_port_allocate()` inside setup_receive_port. 

The function `setup_receive_port` uses the `mach_port_allocate()` function to create a port with the receive port rights and inserts rights into the current task to send messages to the newly allocated port.

The function `send_port` creates a custom message structure with the required body and header structures we defined earlier and then sets the metadata for the message, which happens to be a port descriptor that contains the port name of the parent's task. At last it sends the message to the remote port, which in this case is the child's receive port.

In the function `receive_port`, `mach_msg()` processes the next message the receive port has in its message queue and gets the task port of the parent from the message's metadata.

Using mach_ports to process messages is an important concept for IPC within Mach.




