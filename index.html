<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>YungRaj</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
    <div class="wrapper">

      <section>
        <div id="title">
          <h1>YungRaj's blog ðŸ”¥</h1>
          <h5>Security, reverse engineering, firmware and machine research</h5>
          <hr>
          <span class="credits left">A blog by <a href="https://github.com/YungRaj">YungRaj</a>&emsp;<a href="https://twitter.com/ilhanraja">@ilhanraja</a></span>
          <span class="credits right">This site is released under the terms of the MIT license.</span>
        </div>

        <p>This is currently my blog for future research for iOS, macOS, UEFI, and many more platforms. It also a host to my MobileSubstrate tweaks that are also available on Cydia and other software projects on github</p>
        <h3>About me</h3>
        <p>I am a student at TAMU in College Station, Texas. I know C, C++, Objective C, Swift, Java, x86/ARM ASM and even some ACPI Machine Language. I have been interested with iOS/macOS and UEFI/BIOS software development since high school and am now going to document my research for people to readily be able to learn. Email me at ilhan.raja@icloud.com if you have any questions. Here is a link to my <a href="https://github.com/YungRaj/YungRaj.github.io/raw/master/_site/Resume.pdf"> Resume</a><p>
        <h4>Method Hooking</h4>
        <span style="color:orange;">01-31-2017</span>
        <p>So you're writing tweaks for iOS and wanted to understand more what is being done? What you're about to find is a concise, detailed explanation about what is going on under the hood when hooking into software during runtime. Previous experience with Objective C is required.<br></p>
        <span style="color:orange;">The Objective C Runtime</span>
            <br>&emsp;&emsp;&emsp;Objective C is the primary language that Apple uses for application development in the userspace. It is an object oriented language and runtime written in C. It has been used for years ever since the inception of NextStep, later acquired by (you'd never figure this out) Apple, where the standard frameworks originated from.<br>
                &emsp;&emsp;&emsp;Although Swift is growing more popular, its runtime libraries are still not locally stored on the filesystem and end up having to be packaged into the app bundle (remaining dynamically linked) of an application that depends on code written in Swift. I'm not sure why Apple does this, my original assumption is that the ABI support is not fully complete. In addition, Swift has to rely on the frameworks and libraries that were written in Objective C. So least for now, Objective C remains strong.<br>
                &emsp;&emsp;&emsp;Anyway, the magical part about Objective C seems to be that it supports something called reflection, which is the ability for computer program to introspect, examine, and even modify the internal structures and behavior during runtime. Although one might feel this is a super large strength of Objective C, a person, given the security mitigations within iOS/macOS, can not take realistically take advantage of such language features effectively without fundamental changes. The changes described are for another post. <br>
                &emsp;&emsp;&emsp;As far as reflection goes, let's take a look at the runtime headers of the Objective C runtime library, which is dynamically linked into a Mach-O binary everytime an app depends on Objective C code. In objc/runtime.h and objc/objc.h,
                <pre>
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;
#if !__OBJC2__
    Class super_class
    const char *name
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
                </pre>
                &emsp;&emsp;&emsp;We find that an objc_class is a structure of many different fields that basically define the abstract concept of a class. From basic programming experience, a Class conceptually should have a super class, a way to identify the type of class (in this case it is by string), instance variables, methods, etc. Protocols may not be familiar to non-objective c developers, but they are just an added language feature that is well documented.
                    <pre>
#if !OBJC_TYPES_DEFINED
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class;
/// Represents an instance of a class. </pre>
                &emsp;&emsp;&emsp;If you happen to be confused as to what the predefined type Class was, it is typedef to a pointer to an objc_class type. This would be important since we don't have to copy data over and over if it happens to change during runtime (which would be the case since objc supports reflection) or when passing objects as parameters to methods/functions.
                    <pre>
struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
/// A pointer to an instance of a class.
typedef struct objc_object *id;
#endif
/* Use `Class` instead of `struct objc_class *` */
</pre>
                &emsp;&emsp;&emsp;And astoundingly, the only field of the objc_object structure is just a pointer to an instance of a Class. We also find that id, a widely used keyword, is also defined which is just typedef to a pointer to a objc_object (or nil).<br><br>
                &emsp;&emsp;&emsp;Objective C happens to use something called a metaclass system, which, in short, basically defines a mutual relationship between objects and classes. Classes are objects, and objects are instances of classes. This means that we can send messages to both a class and an object.<br>
                &emsp;&emsp;&emsp;To better explain this, a good example would be the NSString class. <br>
                &emsp;&emsp;&emsp;[NSString stringWithFormat:] is a class method call that returns a pointer to an NSString. NSString is of type Class, and is an object too because a message can be passed to it (the selector stringWithFormat:). Conversely, the pointer to an NSString* object that is returned from that class method call at a lower level is an instance of a Class. This is the case because a pointer to an id (pointer to any Objective C object) has only one member, what is known as the isa pointer (of type Class or objc_class*).
        </p>
        <pre>
struct objc_category {
    char *category_name                                      OBJC2_UNAVAILABLE;
    char *class_name                                         OBJC2_UNAVAILABLE;
    struct objc_method_list *instance_methods                OBJC2_UNAVAILABLE;
    struct objc_method_list *class_methods                   OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
}                                                            OBJC2_UNAVAILABLE;
            
struct objc_ivar {
    char *ivar_name                                          OBJC2_UNAVAILABLE;
    char *ivar_type                                          OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}                                                            OBJC2_UNAVAILABLE;
            
struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
}

/// An opaque type that represents a method selector.
typedef struct objc_selector *SEL;

/// A pointer to the function of a method implementation.
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ );
#else
typedef id (*IMP)(id, SEL, ...);
#endif
</pre>
        &emsp;&emsp;&emsp;And here we find more definitions of objc categories, ivars, methods, selectors and IMPs (implementation [basically a function pointer]).
        <br>
        <br>
        &emsp;&emsp;&emsp;You might ask, "why is knowing this important?". Well firstly, this sets up your knowledge of the Objective C runtime. After understanding the basic types within the runtime, I can then explain how reflection works.
        <br>
        &emsp;&emsp;&emsp;So now you know the underlying data structures that make up the runtime. But how are they used?<br>
        &emsp;&emsp;&emsp;The runtime includes many functions that create and modify these intrinsic structures. A list is shown below.
        <pre>
Classes
    class_getName
    class_getSuperclass
    class_isMetaClass
    class_getInstanceSize
    class_getInstanceVariable
    class_getClassVariable
    class_addIvar
    class_copyIvarList
    class_getIvarLayout
    class_setIvarLayout
    class_getWeakIvarLayout
    class_setWeakIvarLayout
    class_getProperty
    class_copyPropertyList
    class_addMethod
    class_getInstanceMethod
    class_getClassMethod
    class_copyMethodList
    class_replaceMethod
    class_getMethodImplementation
    class_getMethodImplementation_stret
    class_respondsToSelector
    class_addProtocol
    class_addProperty
    class_replaceProperty
    class_conformsToProtocol
    class_copyProtocolList
            
Adding Classes during Runtime
    objc_allocateClassPair
    objc_disposeClassPair
    objc_registerClassPair
    objc_duplicateClass
            
Creating Instances of Classes
    class_createInstance
    objc_constructInstance.
    objc_destructInstance
            
Instances
    object_copy
    object_dispose
    object_setInstanceVariable
    object_getInstanceVariable
    object_getIndexedIvars
    object_getIvar
    object_setIvar
    object_getClassName
    object_getClass
    object_setClass

Classes (contâ€™d)
    objc_getClassList
    objc_copyClassList
    objc_lookUpClass
    objc_getClass.
    objc_getRequiredClass
    objc_getMetaClass
    
Message Sending
    objc_msgSend
    objc_msgSend_fpret
    objc_msgSend_stret
    objc_msgSendSuper
    objc_msgSendSuper_stret

Methods
    method_invoke
    method_invoke_stret
    method_getName
    method_getImplementation
    method_getTypeEncoding
    method_copyReturnType
    method_copyArgumentType
    method_getReturnType
    method_getNumberOfArguments
    method_getArgumentType
    method_getDescription
    method_setImplementation
    method_exchangeImplementations
</pre>
        &emsp;&emsp;&emsp;With any of these functions, the runtime is able to perform the underlying behavior that the normal developer doesn't have to worry about in their process. There are more functions to the runtime not documented in this post, but these are the most relevant to reflection and method hooking. Now let's talk about some noteworthy functions that are important to us. <br>
        &emsp;&emsp;&emsp;id objc_msgSend(id self, SEL op, ...) and its counterparts send a message to an instance of a class. Method dispatching works a little differently in Objective C in comparison to other languages such as C++, Java and even Swift, which use virtual function tables to find the right method to jump to. The way that Objective C handles method dispatching is by using the meta-class structure (the isa pointer) to find the right selector and arguments. objc_msgSend starts where self points to (an id.. i.e. a pointer to an objc_object) and looks inside the isa pointer if it contains the right method in the method list. If it doesn't, it looks within the superclass, which is another type of Class in memory. If it goes through the whole class hierarchy and does not find a method that is dispatchable, the program aborts (usually an EXC_CRASH SIGABRT [unix signal abort]) and the operating system is forced to recover from it via an exception. When I discuss exceptions, traps, and interrupts in XNU, you'd able to know how that works in a much deeper level. But for now, let's stay on topic. <br>
        &emsp;&emsp;&emsp; The functions prefixed with class_ generally perform operations on classes or retrieves data from them. They are self explanatory and will be implemented in code samples in a future portion of this post, and this should clarify in detail about how they work. <br>
        &emsp;&emsp;&emsp;During runtime, you can even manually create classes and construct instances of them without the formal syntax that Objective C uses. Those are depicted by the sections "Adding Classes during Runtime" and "Creating Instances of Classes". <br>
        &emsp;&emsp;&emsp;objc_getClass returns the type of class that you would like during runtime. If the class you're querying is local to the process you're trying to use, then this syntax generally isn't needed. In special cases like writing tweaks and hooking into classes in a separate process via MobileSubstrate, you'll find a need for these functions. Below is an example of basic retrieval of Classes during runtime. <br>
        <pre>
// retrieval of Classes via objc_getClassList
int numClasses;
Class *classes = NULL;
// first get the number of classes so we can dynamically allocate a pointer to them
numClasses = objc_getClassList(NULL, 0);

if (numClasses > 0 ){
    // allocate a pointer to all the Classes using the numClasses variable
    classes = (__unsafe_unretained Class *)malloc(sizeof(Class) * numClasses);
    // get them and store them into the classes pointer
    numClasses = objc_getClassList(classes, numClasses);
    for (int i = 0; i < numClasses; i++) {
        // print the name of the class via class_getName
        NSLog(@"Class name: %s", class_getName(classes[i]));
    }
    free(classes);
}
        </pre>
        &emsp;&emsp;&emsp;The section for Methods is self explanatory. Code samples would better depict the usage of these functions so stay tuned. <br>
        <h5>StreakNotify</h5>
        <span style="color:orange;">01-10-2017</span>
        <p>I recented talked to CokePokes about the recent changes within Snapchat with regards to DRM, and concluded that the best solution for allowing compatibility with Phantom is to include my code within the Phantom project. I will remain the maintainer of my code, however I will be collaborating with CokePokes to update StreakNotify/Phantom to combat Snapchat's DRM. BUT, if you only want to install StreakNotify alone, you can since it by itself does not activate Snapchat's DRM. To install my tweak through BigBoss on Cydia, use this <a href="http://cydia.saurik.com/package/com.yungraj.streaknotify/"> link.</a> I will still be pushing updates to this tweak for the newest versions and doing the best I can to add more features/fix bugs. If you have any questions, you can email me.</p>
        
        <h6>First post</h6>
        <p>I appreciate the time taken to look at the work that I've been doing. As I do research I will document my findings about the Objective C/Swift Runtime under the hood, XNU/Darwin, EFI/UEFI, and much more.</p>

    <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
  </body>
</html>
